"use strict";(self.webpackChunkcoding_standard=self.webpackChunkcoding_standard||[]).push([[71],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||c[m]||a;return n?o.createElement(h,i(i({ref:t},u),{},{components:n})):o.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<a;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2832:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return u},default:function(){return p}});var o=n(7462),r=n(3366),a=(n(7294),n(3905)),i=["components"],s={sidebar_position:9},l="Going To Production",d={unversionedId:"going-to-production-practices",id:"going-to-production-practices",isDocsHomePage:!1,title:"Going To Production",description:"Monitoring",source:"@site/docs/going-to-production-practices.md",sourceDirName:".",slug:"/going-to-production-practices",permalink:"/docs/going-to-production-practices",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/going-to-production-practices.md",version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Testing",permalink:"/docs/testing/testring-and-overall-quality-practice"},next:{title:"Security Practices",permalink:"/docs/security-practices"}},u=[{value:"Monitoring",id:"monitoring",children:[]},{value:"Increase transparency using smart logging",id:"increase-transparency-using-smart-logging",children:[]},{value:"Delegate anything possible (e.g. gzip, SSL) to a reverse proxy",id:"delegate-anything-possible-eg-gzip-ssl-to-a-reverse-proxy",children:[]},{value:"Lock dependencies",id:"lock-dependencies",children:[]},{value:"Guard process uptime using the right tool",id:"guard-process-uptime-using-the-right-tool",children:[]},{value:"Utilize all CPU cores",id:"utilize-all-cpu-cores",children:[]},{value:"Create a \u2018maintenance endpoint\u2019",id:"create-a-maintenance-endpoint",children:[]},{value:"Discover errors and downtime using APM products",id:"discover-errors-and-downtime-using-apm-products",children:[]},{value:"Make your code production-ready",id:"make-your-code-production-ready",children:[]},{value:"Measure and guard the memory usage",id:"measure-and-guard-the-memory-usage",children:[]},{value:"Get your frontend assets out of Node",id:"get-your-frontend-assets-out-of-node",children:[]},{value:"Be stateless, kill your servers almost every day",id:"be-stateless-kill-your-servers-almost-every-day",children:[]},{value:"Use tools that automatically detect vulnerabilities",id:"use-tools-that-automatically-detect-vulnerabilities",children:[]},{value:"Assign a transaction id to each log statement",id:"assign-a-transaction-id-to-each-log-statement",children:[]},{value:"Set <code>NODE_ENV=production</code>",id:"set-node_envproduction",children:[]},{value:"Design automated, atomic and zero-downtime deployments",id:"design-automated-atomic-and-zero-downtime-deployments",children:[]},{value:"Use an LTS release of Node.js",id:"use-an-lts-release-of-nodejs",children:[]},{value:"Don&#39;t route logs within the app",id:"dont-route-logs-within-the-app",children:[]},{value:"Install your packages with <code>npm ci</code>",id:"install-your-packages-with-npm-ci",children:[]}],c={toc:u};function p(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"going-to-production"},"Going To Production"),(0,a.kt)("h2",{id:"monitoring"},"Monitoring"),(0,a.kt)("p",null,"Monitoring is a game of finding out issues before customers do \u2013 obviously this should be assigned unprecedented importance. The market is overwhelmed with offers thus consider starting with defining the basic metrics you must follow (my suggestions inside), then go over additional fancy features and choose the solution that ticks all boxes. Click \u2018The Gist\u2019 below for an overview of the solutions"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Failure === disappointed customers. Simple"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"increase-transparency-using-smart-logging"},"Increase transparency using smart logging"),(0,a.kt)("p",null,"Logs can be a dumb warehouse of debug statements or the enabler of a beautiful dashboard that tells the story of your app. Plan your logging platform from day 1: how logs are collected, stored and analyzed to ensure that the desired information (e.g. error rate, following an entire transaction through services and servers, etc) can really be extracted"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," You end up with a black box that is hard to reason about, then you start re-writing all logging statements to add additional information"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"delegate-anything-possible-eg-gzip-ssl-to-a-reverse-proxy"},"Delegate anything possible (e.g. gzip, SSL) to a reverse proxy"),(0,a.kt)("p",null,"Node is awfully bad at doing CPU intensive tasks like gzipping, SSL termination, etc. You should use \u2018real\u2019 middleware services like nginx, HAproxy or cloud vendor services instead"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Your poor single thread will stay busy doing infrastructural tasks instead of dealing with your application core and performance will degrade accordingly"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"lock-dependencies"},"Lock dependencies"),(0,a.kt)("p",null,"Your code must be identical across all environments, but amazingly npm lets dependencies drift across environments by default \u2013 when you install packages at various environments it tries to fetch packages\u2019 latest patch version. Overcome this by using npm config files, .npmrc, that tell each environment to save the exact (not the latest) version of each package. Alternatively, for finer grained control use ",(0,a.kt)("inlineCode",{parentName:"p"},"npm shrinkwrap"),". ","*","Update: as of NPM5, dependencies are locked by default. The new package manager in town, Yarn, also got us covered by default"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," QA will thoroughly test the code and approve a version that will behave differently in production. Even worse, different servers in the same production cluster might run different code"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"guard-process-uptime-using-the-right-tool"},"Guard process uptime using the right tool"),(0,a.kt)("p",null,"The process must go on and get restarted upon failures. For simple scenarios, process management tools like PM2 might be enough but in today's \u2018dockerized\u2019 world, cluster management tools should be considered as well"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Running dozens of instances without a clear strategy and too many tools together (cluster management, docker, PM2) might lead to DevOps chaos"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"utilize-all-cpu-cores"},"Utilize all CPU cores"),(0,a.kt)("p",null,"At its basic form, a Node app runs on a single CPU core while all others are left idling. It\u2019s your duty to replicate the Node process and utilize all CPUs \u2013 For small-medium apps you may use Node Cluster or PM2. For a larger app consider replicating the process using some Docker cluster (e.g. K8S, ECS) or deployment scripts that are based on Linux init system (e.g. systemd)"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Your app will likely utilize only 25% of its available resources(!) or even less. Note that a typical server has 4 CPU cores or more, naive deployment of Node.js utilizes only 1 (even using PaaS services like AWS beanstalk!)"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"create-a-maintenance-endpoint"},"Create a \u2018maintenance endpoint\u2019"),(0,a.kt)("p",null,"Expose a set of system-related information, like memory usage and REPL, etc in a secured API. Although it\u2019s highly recommended to rely on standard and battle-tested tools, some valuable information and operations are easier done using code"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," You\u2019ll find that you\u2019re performing many \u201cdiagnostic deploys\u201d \u2013 shipping code to production only to extract some information for diagnostic purposes"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"discover-errors-and-downtime-using-apm-products"},"Discover errors and downtime using APM products"),(0,a.kt)("p",null,"Application monitoring and performance products (a.k.a. APM) proactively gauge codebase and API so they can auto-magically go beyond traditional monitoring and measure the overall user-experience across services and tiers. For example, some APM products can highlight a transaction that loads too slow on the end-user's side while suggesting the root cause"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," You might spend great effort on measuring API performance and downtimes, probably you\u2019ll never be aware which is your slowest code parts under real-world scenario and how these affect the UX"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"make-your-code-production-ready"},"Make your code production-ready"),(0,a.kt)("p",null,"Code with the end in mind, plan for production from day 1. This sounds a bit vague so I\u2019ve compiled a few development tips that are closely related to production maintenance (click Gist below)"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," A world champion IT/DevOps guy won\u2019t save a system that is badly written"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"measure-and-guard-the-memory-usage"},"Measure and guard the memory usage"),(0,a.kt)("p",null,"Node.js has controversial relationships with memory: the v8 engine has soft limits on memory usage (1.4GB) and there are known paths to leak memory in Node\u2019s code \u2013 thus watching Node\u2019s process memory is a must. In small apps, you may gauge memory periodically using shell commands but in medium-large apps consider baking your memory watch into a robust monitoring system"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Your process memory might leak a hundred megabytes a day like how it happened at ",(0,a.kt)("a",{parentName:"p",href:"https://www.joyent.com/blog/walmart-node-js-memory-leak"},"Walmart")),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"get-your-frontend-assets-out-of-node"},"Get your frontend assets out of Node"),(0,a.kt)("p",null,"Serve frontend content using dedicated middleware (nginx, S3, CDN) because Node performance really gets hurt when dealing with many static files due to its single-threaded model"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Your single Node thread will be busy streaming hundreds of html/images/angular/react files instead of allocating all its resources for the task it was born for \u2013 serving dynamic content"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"be-stateless-kill-your-servers-almost-every-day"},"Be stateless, kill your servers almost every day"),(0,a.kt)("p",null,"Store any type of data (e.g. user sessions, cache, uploaded files) within external data stores. Consider \u2018killing\u2019 your servers periodically or use \u2018serverless\u2019 platform (e.g. AWS Lambda) that explicitly enforces a stateless behavior"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Failure at a given server will result in application downtime instead of just killing a faulty machine. Moreover, scaling-out elasticity will get more challenging due to the reliance on a specific server"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"use-tools-that-automatically-detect-vulnerabilities"},"Use tools that automatically detect vulnerabilities"),(0,a.kt)("p",null,"Even the most reputable dependencies such as Express have known vulnerabilities (from time to time) that can put a system at risk. This can be easily tamed using community and commercial tools that constantly check for vulnerabilities and warn (locally or at GitHub), some can even patch them immediately"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Keeping your code clean from vulnerabilities without dedicated tools will require you to constantly follow online publications about new threats. Quite tedious"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"assign-a-transaction-id-to-each-log-statement"},"Assign a transaction id to each log statement"),(0,a.kt)("p",null,"Also known as correlation id / transit id / tracing id / request id / request context / etc."),(0,a.kt)("p",null,"Assign the same identifier, transaction-id: {some value}, to each log entry within a single request. Then when inspecting errors in logs, easily conclude what happened before and after. Until version 14 of Node, this was not easy to achieve due to Node's async nature, but since AsyncLocalStorage came to town, this became possible and easy than ever. see code examples inside"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Looking at a production error log without the context \u2013 what happened before \u2013 makes it much harder and slower to reason about the issue"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"set-node_envproduction"},"Set ",(0,a.kt)("inlineCode",{parentName:"h2"},"NODE_ENV=production")),(0,a.kt)("p",null,"Set the environment variable ",(0,a.kt)("inlineCode",{parentName:"p"},"NODE_ENV")," to \u2018production\u2019 or \u2018development\u2019 to flag whether production optimizations should get activated \u2013 many npm packages determine the current environment and optimize their code for production"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Omitting this simple property might greatly degrade performance. For example, when using Express for server-side rendering omitting ",(0,a.kt)("inlineCode",{parentName:"p"},"NODE_ENV")," makes it slower by a factor of three!"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"design-automated-atomic-and-zero-downtime-deployments"},"Design automated, atomic and zero-downtime deployments"),(0,a.kt)("p",null,"Research shows that teams who perform many deployments lower the probability of severe production issues. Fast and automated deployments that don\u2019t require risky manual steps and service downtime significantly improve the deployment process. You should probably achieve this using Docker combined with CI tools as they became the industry standard for streamlined deployment"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Long deployments -> production downtime & human-related error -> team unconfident in making deployment -> fewer deployments and features"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"use-an-lts-release-of-nodejs"},"Use an LTS release of Node.js"),(0,a.kt)("p",null,"Ensure you are using an LTS version of Node.js to receive critical bug fixes, security updates and performance improvements"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Newly discovered bugs or vulnerabilities could be used to exploit an application running in production, and your application may become unsupported by various modules and harder to maintain"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"dont-route-logs-within-the-app"},"Don't route logs within the app"),(0,a.kt)("p",null,"Log destinations should not be hard-coded by developers within the application code, but instead should be defined by the execution environment the application runs in. Developers should write logs to ",(0,a.kt)("inlineCode",{parentName:"p"},"stdout")," using a logger utility and then let the execution environment (container, server, etc.) pipe the ",(0,a.kt)("inlineCode",{parentName:"p"},"stdout")," stream to the appropriate destination (i.e. Splunk, Graylog, ElasticSearch, etc.)."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," Application handling log routing === hard to scale, loss of logs, poor separation of concerns"),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"install-your-packages-with-npm-ci"},"Install your packages with ",(0,a.kt)("inlineCode",{parentName:"h2"},"npm ci")),(0,a.kt)("p",null,"You have to be sure that production code uses the exact version of the packages you have tested it with. Run ",(0,a.kt)("inlineCode",{parentName:"p"},"npm ci")," to strictly do a clean install of your dependencies matching package.json and package-lock.json. Using this command is recommended in automated environments such as continuous integration pipelines."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Otherwise:")," QA will thoroughly test the code and approve a version that will behave differently in production. Even worse, different servers in the same production cluster might run different code."),(0,a.kt)("br",null))}p.isMDXComponent=!0}}]);