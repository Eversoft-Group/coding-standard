"use strict";(self.webpackChunkcoding_standard=self.webpackChunkcoding_standard||[]).push([[826],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=c(n),h=s,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||r;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,i=new Array(r);i[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5244:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var a=n(7462),s=n(3366),r=(n(7294),n(3905)),i=["components"],o={sidebar_position:4},l="Testing",c={unversionedId:"testing/testring-and-overall-quality-practice",id:"testing/testring-and-overall-quality-practice",isDocsHomePage:!1,title:"Testing",description:"At the very least, write API (component) testing",source:"@site/docs/testing/testring-and-overall-quality-practice.md",sourceDirName:"testing",slug:"/testing/testring-and-overall-quality-practice",permalink:"/coding-standard/docs/testing/testring-and-overall-quality-practice",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/testing/testring-and-overall-quality-practice.md",version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Error Handling",permalink:"/coding-standard/docs/error-handling-practices/error-handling"},next:{title:"Going To Production",permalink:"/coding-standard/docs/going-to-production-practices"}},u=[{value:"At the very least, write API (component) testing",id:"at-the-very-least-write-api-component-testing",children:[]},{value:"Include 3 parts in each test name",id:"include-3-parts-in-each-test-name",children:[]},{value:"Structure tests by the AAA pattern",id:"structure-tests-by-the-aaa-pattern",children:[]},{value:"4 Detect code issues with a linter",id:"4-detect-code-issues-with-a-linter",children:[]},{value:"Avoid global test fixtures and seeds, add data per-test",id:"avoid-global-test-fixtures-and-seeds-add-data-per-test",children:[]},{value:"Constantly inspect for vulnerable dependencies",id:"constantly-inspect-for-vulnerable-dependencies",children:[]},{value:"Tag your tests",id:"tag-your-tests",children:[]},{value:"Check your test coverage, it helps to identify wrong test patterns",id:"check-your-test-coverage-it-helps-to-identify-wrong-test-patterns",children:[]},{value:"Inspect for outdated packages",id:"inspect-for-outdated-packages",children:[]},{value:"Use production-like environment for e2e testing",id:"use-production-like-environment-for-e2e-testing",children:[]},{value:"Refactor regularly using static analysis tools",id:"refactor-regularly-using-static-analysis-tools",children:[]},{value:"Carefully choose your CI platform (Jenkins vs CircleCI vs Travis vs Rest of the world)",id:"carefully-choose-your-ci-platform-jenkins-vs-circleci-vs-travis-vs-rest-of-the-world",children:[]},{value:"Test your middlewares in isolation",id:"test-your-middlewares-in-isolation",children:[]}],d={toc:u};function p(e){var t=e.components,n=(0,s.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"testing"},"Testing"),(0,r.kt)("h2",{id:"at-the-very-least-write-api-component-testing"},"At the very least, write API (component) testing"),(0,r.kt)("p",null,"Most projects just don't have any automated testing due to short timetables or often the 'testing project' ran out of control and was abandoned. For that reason, prioritize and start with API testing which is the easiest way to write and provides more coverage than unit testing (you may even craft API tests without code using tools like ",(0,r.kt)("a",{parentName:"p",href:"https://www.getpostman.com/"},"Postman"),"). Afterward, should you have more resources and time, continue with advanced test types like unit testing, DB testing, performance testing, etc"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," You may spend long days on writing unit tests to find out that you got only 20% system coverage"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"include-3-parts-in-each-test-name"},"Include 3 parts in each test name"),(0,r.kt)("p",null,"Make the test speak at the requirements level so it's self-explanatory also to QA engineers and developers who are not familiar with the code internals. State in the test name what is being tested (unit under test), under what circumstances, and what is the expected result"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," A deployment just failed, a test named \u201cAdd product\u201d failed. Does this tell you what exactly is malfunctioning?"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"structure-tests-by-the-aaa-pattern"},"Structure tests by the AAA pattern"),(0,r.kt)("p",null,"Structure your tests with 3 well-separated sections: Arrange, Act & Assert (AAA). The first part includes the test setup, then the execution of the unit under test, and finally the assertion phase. Following this structure guarantees that the reader spends no brain CPU on understanding the test plan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," Not only you spend long daily hours on understanding the main code, but now also what should have been the simple part of the day (testing) stretches your brain"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"4-detect-code-issues-with-a-linter"},"4 Detect code issues with a linter"),(0,r.kt)("p",null,"Use a code linter to check the basic quality and detect anti-patterns early. Run it before any test and add it as a pre-commit git-hook to minimize the time needed to review and correct any issue. Also check ",(0,r.kt)("a",{parentName:"p",href:"#3-code-style-practices"},"Section 3")," on Code Style Practices"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," You may let pass some anti-pattern and possible vulnerable code to your production environment."),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"avoid-global-test-fixtures-and-seeds-add-data-per-test"},"Avoid global test fixtures and seeds, add data per-test"),(0,r.kt)("p",null,"To prevent test coupling and easily reason about the test flow, each test should add and act on its own set of DB rows. Whenever a test needs to pull or assume the existence of some DB data - it must explicitly add that data and avoid mutating any other records"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," Consider a scenario where deployment is aborted due to failing tests, team is now going to spend precious investigation time that ends in a sad conclusion: the system works well, the tests however interfere with each other and break the build"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"constantly-inspect-for-vulnerable-dependencies"},"Constantly inspect for vulnerable dependencies"),(0,r.kt)("p",null,"Even the most reputable dependencies such as Express have known vulnerabilities. This can get easily tamed using community and commercial tools such as \ud83d\udd17 ",(0,r.kt)("a",{parentName:"p",href:"https://docs.npmjs.com/cli/audit"},"npm audit")," and \ud83d\udd17 ",(0,r.kt)("a",{parentName:"p",href:"https://snyk.io"},"snyk.io")," that can be invoked from your CI on every build"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," Keeping your code clean from vulnerabilities without dedicated tools will require to constantly follow online publications about new threats. Quite tedious"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"tag-your-tests"},"Tag your tests"),(0,r.kt)("p",null,"Different tests must run on different scenarios: quick smoke, IO-less, tests should run when a developer saves or commits a file, full end-to-end tests usually run when a new pull request is submitted, etc. This can be achieved by tagging tests with keywords like #cold #api #sanity so you can grep with your testing harness and invoke the desired subset. For example, this is how you would invoke only the sanity test group with ",(0,r.kt)("a",{parentName:"p",href:"https://mochajs.org/"},"Mocha"),": mocha --grep 'sanity'"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," Running all the tests, including tests that perform dozens of DB queries, any time a developer makes a small change can be extremely slow and keeps developers away from running tests"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"check-your-test-coverage-it-helps-to-identify-wrong-test-patterns"},"Check your test coverage, it helps to identify wrong test patterns"),(0,r.kt)("p",null,"Code coverage tools like ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/istanbuljs/istanbuljs"},"Istanbul"),"/",(0,r.kt)("a",{parentName:"p",href:"https://github.com/istanbuljs/nyc"},"NYC")," are great for 3 reasons: it comes for free (no effort is required to benefit this reports), it helps to identify a decrease in testing coverage, and last but not least it highlights testing mismatches: by looking at colored code coverage reports you may notice, for example, code areas that are never tested like catch clauses (meaning that tests only invoke the happy paths and not how the app behaves on errors). Set it to fail builds if the coverage falls under a certain threshold"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," There won't be any automated metric telling you when a large portion of your code is not covered by testing"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"inspect-for-outdated-packages"},"Inspect for outdated packages"),(0,r.kt)("p",null,"Use your preferred tool (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"npm outdated")," or ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/npm-check-updates"},"npm-check-updates"),") to detect installed outdated packages, inject this check into your CI pipeline and even make a build fail in a severe scenario. For example, a severe scenario might be when an installed package is 5 patch commits behind (e.g. local version is 1.3.1 and repository version is 1.3.8) or it is tagged as deprecated by its author - kill the build and prevent deploying this version"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," Your production will run packages that have been explicitly tagged by their author as risky"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"use-production-like-environment-for-e2e-testing"},"Use production-like environment for e2e testing"),(0,r.kt)("p",null,"End to end (e2e) testing which includes live data used to be the weakest link of the CI process as it depends on multiple heavy services like DB. Use an environment which is as close to your real production environment as possible like a-continue (Missed -continue here, needs content. Judging by the ",(0,r.kt)("strong",{parentName:"p"},"Otherwise")," clause, this should mention docker-compose)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," Without docker-compose, teams must maintain a testing DB for each testing environment including developers' machines, keep all those DBs in sync so test results won't vary across environments"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"refactor-regularly-using-static-analysis-tools"},"Refactor regularly using static analysis tools"),(0,r.kt)("p",null,"Using static analysis tools helps by giving objective ways to improve code quality and keeps your code maintainable. You can add static analysis tools to your CI build to fail when it finds code smells. Its main selling points over plain linting are the ability to inspect quality in the context of multiple files (e.g. detect duplications), perform advanced analysis (e.g. code complexity), and follow the history and progress of code issues. Two examples of tools you can use are ",(0,r.kt)("a",{parentName:"p",href:"https://www.sonarqube.org/"},"Sonarqube")," (2,600+ ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/SonarSource/sonarqube"},"stars"),") and ",(0,r.kt)("a",{parentName:"p",href:"https://codeclimate.com/"},"Code Climate")," (1,500+ ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/codeclimate/codeclimate"},"stars"),")."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," With poor code quality, bugs and performance will always be an issue that no shiny new library or state of the art features can fix"),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"carefully-choose-your-ci-platform-jenkins-vs-circleci-vs-travis-vs-rest-of-the-world"},"Carefully choose your CI platform (Jenkins vs CircleCI vs Travis vs Rest of the world)"),(0,r.kt)("p",null,"Your continuous integration platform (CICD) will host all the quality tools (e.g. test, lint) so it should come with a vibrant ecosystem of plugins. ",(0,r.kt)("a",{parentName:"p",href:"https://jenkins.io/"},"Jenkins")," used to be the default for many projects as it has the biggest community along with a very powerful platform at the price of a complex setup that demands a steep learning curve. Nowadays, it has become much easier to set up a CI solution using SaaS tools like ",(0,r.kt)("a",{parentName:"p",href:"https://circleci.com"},"CircleCI")," and others. These tools allow crafting a flexible CI pipeline without the burden of managing the whole infrastructure. Eventually, it's a trade-off between robustness and speed - choose your side carefully"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," Choosing some niche vendor might get you blocked once you need some advanced customization. On the other hand, going with Jenkins might burn precious time on infrastructure setup"),(0,r.kt)("h2",{id:"test-your-middlewares-in-isolation"},"Test your middlewares in isolation"),(0,r.kt)("p",null,"When a middleware holds some immense logic that spans many requests, it is worth testing it in isolation without waking up the entire web framework. This can be easily achieved by stubbing and spying on the {req, res, next} objects"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Otherwise:")," A bug in Express middleware === a bug in all or most requests"),(0,r.kt)("br",null))}p.isMDXComponent=!0}}]);